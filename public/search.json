[{"title":"Arduino - Start Arduino in MacOS","url":"/2024/04/06/arduino-start-up-withMacOS-md/","content":"Install Arduino IDE and test in MacOS\nGo to Arduino Office Website: https://www.arduino.cc/en/software, choosing the download option you need. Then, press the corresponding text button and download it.\nInstall the IDE: after installation, double chick the “.dmg” file. Then, pull the Arduino IDE icon to “Applications” to install the software.\n\n\n\nOpen the IDE from “Launchpad （啟動台）” and enjoy it!\n\nInstall Rosetta 2\nRosetta 2 enables a Mac with Apple silicon to use apps built for a Mac with an Intel processor.\n\n\nFrom: https://support.apple.com/en-us/102527\n\nBecause Arduino development software is built for use on x86-64 processors. So, we need to install Rosetta for it.\nHow to install. In terminal, we just command:\nsoftwareupdate --install-rosetta --agree-to-license\n\nDone!\nWhat if we don’t install RosettaI tested that before for you guys! If we uploaded Arduino code without Rosetta, it would show the compiled error like below content:\nfork/exec /Users/user/Library/Arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino7/bin/avr-g++: bad CPU type in executableCompilation error: fork/exec /Users/user/Library/Arduino15/packages/arduino/tools/avr-gcc/7.3.0-atmel3.6.1-arduino7/bin/avr-g++: bad CPU type in executable\n\n\nTest with Arduino\nRequirement Device:\n\nArduino device, e.g. Arduino UNO R3 board\nCable: type A to type B USB\nUSB hub (All in one to Type C USB)\nMacBook, e.g. MacBook Air M1\n\n\nTest Steps:\n\nConnect the Arduino device with cable and USB hub, like picture below:\n\n\nmake sure Arduino is worked (yellow light keeps flashing)\n\nOpen the Arduino IDE, select the correct Board to connect to your device. After selecting, it will show up your type of Arduino, e.g. “Arduino UNO” for my case.\n\n\n\nTest with the example code: we will test the Arduino with code called “Blink”, and this is a program make your Arduino LED blinking with delay time you set. We open the code from “File” &gt; “Examples” &gt; “01.Basics” &gt; “Blink”, and it will open a window for this code.\n\n\n\nYou can modify the delay time (I set 2 sec in this case), and then chick the “right arrow” button to upload the program into Arduino.\n\n\n\nIf the LED on the Arduino turns on and off every two seconds, that is! Congratulations!\n\nConclusionThis is my first time playing with Arduino on MacOS. Initially, I thought it would be difficult to use Arduino with MacBooks, but I was wrong. Setting it up is as easy as it is on Windows. Finally, I can create some interesting things with my MacBook at home!\n","categories":["LifeDIY"],"tags":["arduino"]},{"title":"Briefly Talk about C++ Class - Object Based","url":"/2024/03/24/cpp-breifly-talk-obj-base/","content":"\n本篇文章會簡單介紹，關於C++ Class類別的簡單概念與使用方法，說明其特色，讓讀者對C++ Class有初步的認識。\n\nWhat is C++ Class\nA class in C++ is a user-defined type or data structure declared with keyword class that has data and functions. (from Wiki)\nC++ Class 我的體驗上，可以做好封裝、程式碼的區隔，在與人協作上會有很好的效果\n我們要如何實作C++的類別呢？我們分為兩個面向來探討\nObject Based: What kind of Class. How to build a Class. 會針對單一個Class，討論如何建構或規劃一個類別中的成員（member）\nObject Oriented: Relationship of multiple Classes. 會討論到物件導向的概念，著重於多個類別的交互作用關係\n\n\n本篇文章，會針對 Object Based 來去做介紹喔！（有機會在討論另一個）\n\nHow to Build a Class - Header File\n對於C++ Class，主要會有兩個相同名稱，但副檔名不同的檔案，一個是header file(.h)，另一個為source file(.cpp)\nheader file: 作為類別成員宣告（declaration）之用，定義某個成員的原型(prototype)\nsource file: 作為前述類別成員的定義(definition)，在header定義的成員會被連結到這裡來，查看並實作出對應的程式\n但詳細的定義，會關乎C++的編譯行為，稍微複雜，有興趣的朋友們可以再做研究～\n\n\n以下就為各位介紹，Header File的各項成員：\n\nHeader File 標頭檔\n通常，標頭檔的副檔名，都會是 “.h“ (header files for own)居多\n#include&lt;&gt;and #include&quot;&quot;\n&lt;&gt;: 用於編譯器定義之資料庫或C++標準資料庫，會優先到系統路徑做尋找\n&quot;&quot;:  用於自定義的標頭檔，或在同一層（或同個專案資料夾）中的資料庫或標頭檔\n可以參考這個\n\n\nHeader Guard\n表示如下，目的是為了保護宣告名稱的“獨特性”，要防止多重載入的狀況發生\n\n\n\n\n\n/* complex.h */#ifndef COMPLEX_ /*如果之前都沒有定義COMPLEX_的話，進入以下程式碼區域；否則跳出*/ #define COMPLEX_// The contexts we write////#endif\n\nClass Members Declaration 類別成員變數、函數定義/* Header file: complex.h */#ifndef COMPLEX_    // Header guard#define COMPLEX_#include &lt;cmath&gt;    // Include other header    ////////////    /// class headclass Complex         // 1. 類－聲明: class declarations&#123;/// class bodypublic:    Complex (double r = 0, double i = 0)        : re (r), im (i)        &#123; &#125;    Complex&amp; operator += (const Complex&amp;); // 定義放在body之外做定義    double real () const &#123; return re; &#125;    // 有些函數可以在此直接定義    double imag () const &#123; return im; &#125;    // 這種定義方式叫做內聯(inline)，優點是編譯速度快，但不能過於複雜    int Function (); // 自定義的函式    // 另外，回傳值前加入const，表示回傳值不可改變private:    double re, im;    &#125;;////////////int Complex::Function() &#123;  ... // 2. 類－定義: class definition&#125; #endif\n\n對於標頭檔中的內容，這邊做個簡單的解釋，這邊大概分成三個部分：\n\nHeader Guard與引用：最上面的區域\n類別聲明（class declarations）: 中間的部分，進行類別成員的聲明動作。在我看來，是在跟系統說「我有這個成員喔！」，接著就會自動引導到類別定義（class definition）去實作這個方法\n類別定義（class definitions）（optional）: 通常，類別定義會出現在對應這個標頭檔的.cpp裏頭，但也可以定義在最下面這部分\n\nHow to Build a Class - Class Members以下會講解，成員函數或變數的相關知識，以及用法。\n我們首要提到的就是成員存取控制（Access Levels），他會對每個類別成員，做存取控制的設定，做好封裝（Encapsulation）管理。\nAccess Levels\n\n\nLevels\nIn Class\nOut of Class\nCan be inherited\n\n\n\npublic\n🆗\n🆗\n🆗\n\n\nprivate\n🆗\n🚫\n🚫\n\n\nprotected\n🆗\n🚫\n🆗\n\n\n\n對上面表格的相關說明：\n我們有三種存取控制階層，分別是public , private 以及protected\n每個階層有其對應的存取範圍，分別是In class, out of class and Can be inherited\nIn Class: 可以在本身自己的類別範圍內存取，存取範圍是最小的。其他類別或繼承他的類別，是無法知道他的存在\nOut of Class: 其他的類別，是可以存取這個類別成員的。好比眾所皆知的公眾人物\nCan be inherited: 表示自身，以及繼承該類別的子類別（又叫 衍生類別，derived class）可以進行存取。就像住在同一個屋簷下，兒子總會知道老爸的一些底細\n\n\n\n\n\nSetter and Getter對於一個無法從外部取得，存取權限為private 的成員變數而言，為了要從外部存取該成員，我們常會加上Setter and Getter來對這個變數做存取管理。\n直接來看以下範例吧！\nclass Employee &#123;private:    int salary_;    public:    // Setter    void set_salary(int s) &#123; salary_ = s; &#125;    // Getter    int salary() const &#123; return salary_; &#125;    // or get_salary()...&#125;\n\n\n程式碼解說：\n目的：我們對Employee 這個類別中的salary_ 這個private 成員，設置Setter and Getter\nSetter: 變異子，賦與值，對salary_進行寫入動作\n深入探討：這個也可以寫成void set_salary(const int&amp; s) &#123; salary_ = s; &#125;，觀察看到小括弧中的const int&amp; 是對s做Pass by Reference to Constant，晚點會講到！\n\n\nGetter: 訪問子，讀取值，對salary_進行數值的讀取\n深入探討：小括弧跟上大括弧之間的const ，會強制以常數方式訪問的成員，比較安全，不會因為訪問而變動到這個數值\n\n\n\n\n\nInline Function內嵌函數，看到內嵌函數，只要記得：當程式碼呼叫到這個函數的話，經過編譯器編譯後，他會直接將他的定義，插入並取代調用他的地方，可以說在原地展開這個函數的定義。\n\n好處：節省了每次調用函數帶來的額外時間開支\n要注意的是，要進行內嵌的函數，不能夠太複雜，且不能是遞回形式，否則編譯器不會理我們\n\n以下為一個內嵌函數的範例：\nclass HelloWorld &#123;public:    void SayHello();&#125;// Out of classinline void HelloWorld::SayHello() &#123;    std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl;&#125;\n\n下面程式碼為編譯器的行為：\n///////// Before Compiled //////////int main() &#123;    HelloWorld hw;    hw.SayHello();&#125;///////// After Compiled //////////int main() &#123;    HelloWorld hw;    //hw.SayHello();    // Directly extent here!    std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl;&#125;\n\nConstructor and Destructor建構子，在類別中是一個重要的函數，當這個類別的物件（Object）被創建時（也就是在程式碼中要呼叫並創建該類別），編譯器總是會尋找跟這個類別匹配的建構子，自動執行建構子中的函數內容。\n這邊簡單講解幾點關於建構子的重點：\n\n建構子函數中，通常會執行：初始化類別中的參數，以及執行其他函數（檢查數值啊，讀取資料等等）\n建構子名稱必須跟類別名稱一樣；且建構子沒有回傳值（沒有return）\n相反的函數為解構子，意思是當這個類別的物件要被刪除（解構）時，會自動呼叫解構子\n如果一個類別沒有定義建構子或解構子時，會使用編譯器預設的建構子或解構子\n\n下面程式碼為String的建構子與解構子範例：\nString::String(const char* cstr = 0) // 建構子&#123;    if (cstr) &#123;    // 判別是否有值        m_data = new char[strlen(cstr)+1];    // 最後在+1 為結束符號&#x27;\\0&#x27;        strcpy(m_data, cstr);    &#125;    else &#123;    // 未指定初始值        m_data = new char[1];        *m_data = &#x27;\\0&#x27;;    &#125;&#125;String::~String() // 解構子&#123;    delete[] m_data;    // 之前是new一個array，因此這邊要刪除array []&#125;\n\n另，關於建構子，也會提到一個深入的觀念，叫做Big of Three三大函數：\n\nConstructor (建構子):String(const char* cstr=0)\n\n\nDestructor (解構子): ~String()\nCopy constructor (複製建構子): String(const String&amp; str)\nCopy assignment operator (設定運算子): String&amp; operator=(const String&amp; str)\n\n在這邊不在做細述，有機會可以在做介紹～\nInitialization List建構子中，初始化參數時，我們會較常使用Initialization List來對參數初始化，會有比較好的執行效能\nClass Point &#123;private:    int x;    int y;public:    Point(int i = 0, int j = 0)        :x(i), y(j)  // &lt;== This is Initialization List    &#123;        /*        Equal to: \t\tPoint(int i = 0, int j = 0) &#123; \t\t\tx = i; \t\t\ty = j; \t\t&#125;         */    &#125;&#125;\n\nPassing and Returning Values撰寫函數時，總會遇到傳遞&#x2F;回傳數值的相關問題，以下列出主要的兩種傳遞方式：\n\nPass&#x2F;Return by value: 被傳遞或回傳的參數值，是不會變動的，會維持原先的初始值。因為只是複製並傳遞當前的參數值進行操作\n好處：原先的數值不會被變動，只是拷貝一份物件進到此函數中操作\n可能的壞處：如果該物件過大時，如一個非常大的字串或struct，可能會影響執行效能，因為每次使用到都要拷貝一份過去\n\n\nPass&#x2F;Return by reference: 傳遞或回傳的對象為這個物件（變數）的地址（Reference），因此當函數對此變數進行數值改動的話，原先的初始值會遭到變動，因為是直接到這個物件的地址去讀取或修改數值\n好處：傳遞快速，不需要拷貝就可以參考到該變數\n可能的壞處：一不小心會將數值修改到，可能會造成隱性的bug; 但可以依照使用情境，實作Pass by Reference to Constant來迴避這個壞處\n\n\n\n以下就來看看，他們怎麼實作吧！\nPass by Value//建構子中，傳遞的double值 r 以及 icomplex (double r = 0, double i = 0)    // Here    : re (r), im (i)    &#123; &#125;\n\nPass by Reference// ostream傳遞位址，os這個變數將會被改變ostream&amp;operator &lt;&lt; (ostream&amp; os, const Complex&amp; x)&#123;        return os &lt;&lt; &#x27;(&#x27; &lt;&lt; real (x) &lt;&lt; &#x27;,&#x27;              &lt;&lt; imag (x) &lt;&lt; &#x27;)&#x27;;&#125;\n\nPass by Reference to ConstantComplex&amp; operator += (const Complex&amp;);// += 右邊的變數，是被加的，不會改變其量值，因此加上const\n\nReturn by Valuedouble real () const &#123; return re; &#125;    // 回傳值，因其沒有位址\n\nReturn by ReferenceComplex&amp; operator += ( const Complex&amp; );    // 回傳的值需要&quot;賦值&quot; 給變數\n\nAppendix - Smart Pointer可以用來取代傳統的pointer方法，更具有強健性、更加可靠，也可以自動做好內存管理，以避免memory leaking的問題\n#include &lt;memory&gt;int* a = new int(0);  // allocate memoryint b = *a;           // dereferencedelete a;             // release resource//////// Use Smart pointer ////////std::unique_ptr&lt;int&gt; a( new int(0) );// or: std::unique_ptr&lt;int&gt; a = make_unique&lt;int&gt;(0);int b = *a;// NO NEED to release &#x27;a&#x27;\n\nAppendix - Enum Class用來取代傳統的enum方法\n\nAppendix - Coding StyleReference：\nhttps://tw-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents.html\nReferenceC++ 物件導向高級程式學習筆記\n科技讀蟲 C++ 建構子\nWhen do we use Initializer List in C++?\n[C++]內嵌函數（inline　function）筆記\nC++ Constructor後面的”:”是什麼鬼意思？ (Initialization List 教學)\n使用 enum class 取代傳統的 enum\n小結這篇文章的初稿，其實是我在公司與同事分享的ＰＰＴ；自己希望將這些重要的概念，寫成文章，將使用方法記錄下來，以便未來自己可以去重複複習，在創建一個類別時，可以有所依據。也希望可以幫助到有需要的朋友們！\n如果文章內容有錯誤的話，歡迎留言與我指教指教！\n","categories":["Software"],"tags":["c++"]},{"title":"DLAI - ChatGPT API [I] - Language Models, the Chat Format and Tokens","url":"/2024/04/15/dlai-chatgpt-api-course-1-md/","content":"\nLink: DLAI - Building Systems with the ChatGPT API\n\nLanguage Models, the Chat Format and Tokens\nLLM在互動過程，是一直依據前面的Input X(前面的句子)，來預測下一個字詞Output Y\n\n\nTokens[Learning][ new][ things][ is][ fun][!]    // [] is one &quot;token&quot;\n\n\n三大提示詞－System, User and Assistant Message\nSystem: sets tone&#x2F;behavior of assistant. 領先於User and Assistant的提示，會去定義GPT的回答方式或回答行為\nSystem 的提示詞，有多種提示用法：\n調整回答長度，或者做角色扮演\n\n\n\n\nAssistant: Chat model &#x2F; LLM response. 亦即ChatGPT的回答，可以先定義前面的提示句，後面讓ChatGPT來完成他\nUser: YOU，也就是使用者的prompt，就問他問題\n\nmessages =  [  &#123;&#x27;role&#x27;:&#x27;system&#x27;,  &#x27;content&#x27;:&quot;&quot;&quot;You are an assistant who\\ responds in the style of Dr Seuss.&quot;&quot;&quot;&#125;, # &#123;#   &#x27;role&#x27;:&#x27;assistant&#x27;,#   &#x27;content&#x27;:&quot;&quot;&quot;...&quot;&quot;&quot;# &#125;,&#123;&#x27;role&#x27;:&#x27;user&#x27;,  &#x27;content&#x27;:&quot;&quot;&quot;write me a very short poem\\ about a happy carrot&quot;&quot;&quot;&#125;,  ]\n\n\nAPI Key\nThere is more secure way to use API Key\n\nfrom dotenv import load_dotenv, find_dotenv_ = load_dotenv(find_dotenv())    # read local .env fileimport osimport openaiopenai.api_key = os.getenv(&#x27;OPENAP_API_KEY&#x27;)\n\nRevolutionizing AI Application\n多虧AI的革新，我們可以快速去使用相關的API，用非常簡短的時間來完成大型語言模型的調教，更快部屬到應用端。\n如何使用API－Call MethodsFunction: get_completionclient = openai.OpenAI()def get_completion(prompt, model=&quot;gpt-3.5-turbo&quot;):    messages = [&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: prompt&#125;]    response = client.chat.completions.create(        model=model,        messages=messages,        temperature=0  # this is the degree of randomness of the model&#x27;s output     )    return response.choices[0].message.content\n\nFunction: get_completion_from_messagesdef get_completion_and_token_count(messages,                                    model=&quot;gpt-3.5-turbo&quot;,                                    temperature=0,                                    max_tokens=500):        response = openai.ChatCompletion.create(        model=model,        messages=messages,        temperature=temperature,         max_tokens=max_tokens,    )        content = response.choices[0].message[&quot;content&quot;]        token_dict = &#123;&#x27;prompt_tokens&#x27;:response[&#x27;usage&#x27;][&#x27;prompt_tokens&#x27;],&#x27;completion_tokens&#x27;:response[&#x27;usage&#x27;][&#x27;completion_tokens&#x27;],&#x27;total_tokens&#x27;:response[&#x27;usage&#x27;][&#x27;total_tokens&#x27;],    &#125;    return content, token_dict##################################################################messages = [&#123;&#x27;role&#x27;:&#x27;system&#x27;,  &#x27;content&#x27;:&quot;&quot;&quot;You are an assistant who responds\\ in the style of Dr Seuss.&quot;&quot;&quot;&#125;,    &#123;&#x27;role&#x27;:&#x27;user&#x27;, &#x27;content&#x27;:&quot;&quot;&quot;write me a very short poem \\  about a happy carrot&quot;&quot;&quot;&#125;,  ] response, token_dict = get_completion_and_token_count(messages)\n\n\nExercise: 星座描述應答軟體概念呈現\nMotivation &amp; Objective: 讓不清楚生日對應甚麼星座的人們，方便查詢星座與該星座的相關細節; 讓使用者可以方便查詢且易於顯示\nInput: 使用者只要輸入 [綽號] 與 [生日日期]\nOutput: 以表格方式顯示：[對應星座] [星座月份日期] [星座性格特質] [優缺點] [愛情觀&#x2F;感情觀]，並以表格的方式呈現\n\n程式碼實作\n環境使用課程中提供的Jupyter note book 進行案例實作\n\nimport osimport openaiimport tiktokenfrom IPython.display import display, Markdown, Latex, HTML, JSONfrom dotenv import load_dotenv, find_dotenv_ = load_dotenv(find_dotenv()) # read local .env fileopenai.api_key  = os.environ[&#x27;OPENAI_API_KEY&#x27;]# OpenAI API Function Definitiondef get_completion_from_messages(messages,                                  model=&quot;gpt-3.5-turbo&quot;,                                  temperature=0,                                  max_tokens=500):    response = openai.ChatCompletion.create(        model=model,        messages=messages,        temperature=temperature, # this is the degree of randomness of the model&#x27;s output        max_tokens=max_tokens, # the maximum number of tokens the model can ouptut     )    return response.choices[0].message[&quot;content&quot;]# Message Definition: System role and User rolemessages =  [  &#123;&#x27;role&#x27;:&#x27;system&#x27;,  &#x27;content&#x27;:&quot;&quot;&quot;You are an assistant who\\ responds in the style of an professional astrologer.\\ User will give you his/her nickname and their birthday.\\ Your goal is reply user that what the star sign they are,\\ and response the below items:\\ 1. What star sign?\\ 2. The date period of the star sign.\\ 3. Character traits of the star sign.\\ 4. Advantages and Disadvantages of the star sign.\\ 5. View of love/view of feelings of the star sign.\\ Please response them with a table style in HTML structure.&quot;&quot;&quot;&#125;,    &#123;&#x27;role&#x27;:&#x27;user&#x27;,  &#x27;content&#x27;:&quot;&quot;&quot;Nickname: Jimmy, Birthday: eighth, Dec&quot;&quot;&quot;&#125;,  ] # Outputresponse = get_completion_from_messages(messages, temperature=1)print(response)display(HTML(response))\n\n輸出結果HTML Code&lt;table&gt;    &lt;tr&gt;        &lt;td&gt;1. Star Sign:&lt;/td&gt;        &lt;td&gt;Sagittarius&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;2. Date Period:&lt;/td&gt;        &lt;td&gt;November 22 - December 21&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;3. Character Traits:&lt;/td&gt;        &lt;td&gt;Adventurous, independent, optimistic, generous, and philosophical.&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;4. Advantages:&lt;/td&gt;        &lt;td&gt;Enthusiastic, open-minded, and great sense of humor.&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;Disadvantages:&lt;/td&gt;        &lt;td&gt;Impatient, tactless, and prone to taking risks.&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;5. View of Love/Feelings:&lt;/td&gt;        &lt;td&gt;Sagittarians value freedom and honesty in relationships, often seeking excitement and new experiences. They may struggle with commitment but are loyal and passionate partners.&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;\n\nOutput View\n\nConclusion以上就是這次的課程筆記。按照課程步驟，在一次體會到提示工程的重要性，良好並完整的提示，對LLM模型的回答而言是很有幫助的。未來，有機會建置屬於自己的API時，system role 的提示詞也要多用點心來撰寫。\n另外，我自己有直接使用 OpenAI API 直接在本地端進行實作，測試過程中發現：使用本地端API沒有免費的使用權限(需要$$)；有鑑於現階段尚無需求，那就先蹭一下課程的API吧~\n","categories":["software"],"tags":["llm/gpt"]},{"title":"Hello World","url":"/2024/02/10/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Hexo at MacOS架站心路歷程：Part I - 環境安裝","url":"/2024/02/29/202403-hexo/hexo_build_part1/","content":"主旨與動機\n想在繁忙的工作生活時間中，找到一個沈靜自己、消化自己收穫的小天地\n用於記錄自己的工作、生活心得體悟\n也分享給有需要的朋友們\n\n心路歷程Ｉ：安裝Hexo必須環境(at MacOS)\n學習連結：https://easyhexo.com/1-Hexo-install-and-config/\n\nStep 1 - 安裝套件管理工具：HomeBrew\n官方連結：https://brew.sh/zh-tw/\n\n\n如同linux系統的apt-get，brew就是ＭＡＣ系統的套件管理工具\n在電腦中的terminal執行下面指令\n\n/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;\n\n\n讓他跑一下，過程中會需要輸入使用者密碼\n接著，安裝好後，系統會提示下兩個指令，設定brew指令至PATH\n\n(echo; echo &#x27;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#x27;) &gt;&gt; /Users/user/.zprofileeval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;\n\n\n設定完指令後，即可測試指令brew是否可以運作！\n\nStep 2 - 安裝 git and Node.js\n下載git套件，下指令安裝git，沒難度：\n\nbrew install git\n\n\n接著，下載套件Node.js，我們將透由nvm這個套件進行下載\nhttps://github.com/nvm-sh/nvm\n\n\n\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash\n\n\n注意：需要先重新啟動終端器，重啟後再輸入以下的指令，來安裝npm\n\nnvm install stable\n\n\n可以輸入以下指令，看是否安裝成功：\n\nnpm --version\n\nStep 3 - 安裝Hexo\n最後，我們就可以使用npm指令來安裝我們的Hexo囉！\n\nnpm install -g hexo-cli\n\n小結安裝的過程蠻簡單的，跟在linux上的使用體驗類似。\n非常感謝各方大神的技術資源提供。\n","categories":["Software"],"tags":["hexo"]},{"title":"Hexo at MacOS架站心路歷程：Part II - Hexo配置","url":"/2024/03/03/202403-hexo/hexo_build_part2/","content":"\n上一篇經歷Hexo的環境安裝，現在就讓我們進行基礎的Hexo配置。\n\nStep 1 - 初始化建立Hexo服務\n首先，創立一個資料夾，我們會在這個資料夾中，建立服務\n\nmkdir &lt;your-dir-name&gt;\n\n\n接著，初始化Hexo服務：\n\nhexo init &lt;your_blog_name&gt;\n\n\n見到狀態：INFO  Start blogging with Hexo!表示已建立成功！\n\nStep 2 - 配置Hexo\n！溫馨提醒！\n可以同時參照官方參考：https://hexo.io/zh-cn/docs/configuration\n要稍微理解YAML的語法：冒號後面，需要一個空格才能繼續寫下去\n\n\n\n這裡建議，直接參考官方的配置說明：https://hexo.io/zh-cn/docs/configuration\n\n如同官方所說，大部分的網頁配置，都是在_config.yml 或 代替配置文件 中調整修改\n\n\nStep 3 - 使用 Hexo 的指令\n以下分享一些常用的Hexo指令，便於操作\n\nhexo init [folder]\nGoal: 初始化Hexo 的相關配置\nParameters:\nfolder: 表是要初始化的文件資料夾地址\n若要直接在當前資料夾初始化，直接輸入hexo init .\n\n\n\nhexo server\nGoal: 可以在本地端進行網站的預覽，同時也是一種Debug方式\n默認的網址連結為http://localhost:8080/ ，可能會有所不同，像我就是4000這個port口\n如果說想要換port地址，可以在終端器輸入hexo s -p &lt;new_port&gt;\n\nhexo generate\nGoal: 用於生成靜態文件，生成後網頁相關內容會放在根目錄下面的public 文件夾中\n\nhexo deploy\nGoal: 用來部署網站內容，使用這個命令會將生成好的頁面（根目錄下面的public 文件夾的內容）部署到指定的地方\n這個指定的地方，可以在_config.yml 進行定義\n\nhexo clean\nGoal: 用於清空public文件夾內容\n\nhexo version\nGoal: 用於輸出目前hexo版本號\n\nStep 4 - 配置主題（我使用Keep）\n我使用的主題為 https://keep.xpoet.cn/\n\n\n如何設定：請參照Keep 官網的示範教學，依序設定\n\n踩雷解決方法\n我用npm的方式下載好keep主題，但看不到相關的主題配置文件？\n解法：在hexo根目錄中，Dir: source 資料夾建立資料夾 _data ，並且在該資料夾底下創建檔案keep.yml 。該主題就會讀取這檔案中的設定配置。\n配置檔案設定路徑：  source/_data/keep.yml\n再follow https://keep-docs.xpoet.cn/basis/configuration-guide/base_info.html 所述去配置。\n\n\n配置的「影像」檔案要放在哪裡？\n文件中（.yml），會寫成/images/xxx.svg\n檔案文件中會存放在：source/images 這個檔案中\n\n\n部署討論區時，該怎麼部署Disqus套件\n請在主題設置文件中，輸入下列程式碼：shortname的部分，可以參照下圖，登入Disqus後，尋找shortname的標籤comment:  enable: true  use: disqus  # values: valine | gitalk | twikoo | waline | giscus | artalk | disqus  # Disqus Setting  disqus:    enable: true    shortname: &lt;your-shortname&gt;    count: true\n\n\n\n\n","categories":["Software"],"tags":["hexo"]},{"title":"Hexo at MacOS架站心路歷程：Part III - Hexo部署架設 - Github Pages 篇","url":"/2024/03/09/202403-hexo/hexo_build_part3-1/","content":"\n上一篇經歷Hexo的設定配置，現在就讓我們進行Hexo的部署架設任務，期待我們的網站出現在網路世界上！\n\n使用Github Pages進行網站部署申請Github Pages\n因為我很早以前申請過了&gt;&lt;，網路上也有各方豪傑的分享可以參考，這邊就先跳過，假設申請好了！\n請記下git申請過後的網址：https://github.com/your_username/your_reponame.git\n\n於本地端建立Github Pages服務\n首先，安裝相關的部署套件\n\n$ npm install hexo-deployer-git --save$ npm install hexo-server --save\n\n\n填寫git的相關標註資訊\n\n$ git config --global user.name &quot;Your_user_name&quot;$ git config --global user.email Your_email@example.com\n\n\n接下來，設定部落格中_config.yml的部署文件\n\ndeploy:  type: git  repo: &lt;your-git-repo-url&gt;  branch: master  message:  # Default is deploy time\n\n\n最後，使用以下指令，將網站生成並部署到github上\n\n$ hexo clean &amp;&amp; hexo d -g\n\n\n如此一來，只要輸入你的github pages網址：https:&#x2F;&#x2F;.github.io&#x2F;，就可以看到你自己架設的網站囉！可喜可賀！\n\n\n小結第一次部署Hexo網站，可以在無邊際的網路海中，看到自己的一點足跡，非常感動！也期勉自己，可以維持這樣的恆心毅力，分享自己的生活工作，希望可以對別人有所幫助！\n","categories":["Software"],"tags":["hexo"]},{"title":"Hexo at MacOS架站心路歷程：Part III - Hexo部署架設 - Netlify + Github 篇","url":"/2024/03/09/202403-hexo/hexo_build_part3-2/","content":"動機與目的\n用了Github Pages部署方式後，發現會有些不方便的地方，比如更新文章時，需要在本地端先進行編譯建置（hexo generate），部署到public文件夾後，再手動上傳資料夾中內容至github更新網頁。\n上網研究，發現Netlify這項好用工具，可以更快速方便的更新自己的網站，做到持續性部署（CD）\n接下來，就讓我們開始吧！\n\n使用Netlify＋Github進行網站部署\nNetlify 是一家遠端優先的雲端運算公司，提供一個開發平台，其中包括針對 Web 應用程式和動態網站的建置、部署和無伺服器後端服務。(Wiki)\n\n\n操作原理\n將Hexo 部落格相關資料，丟到Github建立一個repo\n使用Netlify來建立無伺服器的後端部署服務，並連結至上述repo\nNetlify將會自動偵測Github repo的更新變動，自動進行部署\n\n\n\nStep 1: 將Hexo Project上傳github進行遠端管理\n在部落格的根目錄中，初始git服務，並將我的hexo網頁檔案push上github repo\n\n$ git init$ git add .$ git commit -m &quot;:tada: Init repo&quot;$ git remote add origin git@github.com:&lt;your-github-name&gt;/&lt;hexo-project-name&gt;.git$ git push -u origin master #here need PAT to login your github\n\n\nDebug - git problem with ‘critical error: 身份驗證失敗’\n\n請參考這篇：https://stackoverflow.com/questions/68775869/message-support-for-password-authentication-was-removed\n\n\n\n2021-08-13以後，github不再支援直接輸入密碼的方式，來操作git；而是使用**PAT (Personal Access Token)**作為替代。\n長話短說：請至github頁面申請一組PAT，使用PAT來取代密碼即可。\n\n\nStep 2: 辦理與部署Netlify\n官網：https://www.netlify.com/\n\n\n登入官網後，可以直接使用github帳號做登陸\n填寫完相關資訊，請選擇使用github連動您的hexo repo(剛剛上傳的那個)\n\n\n\n點選剛剛連動的repo，再點選Edit build settings\n\n\n\n修改如下圖所示(其實使用系統預設值即可)\n\n\n\n修改後，即可按下部署「Deploy name to Netlify」並等待發出；成功的話，將會出現下面的資訊囉！\n\n\n\n此時，就可以接著後續的設定，如：客製化網誌ＵＲＬ，或是內嵌入其他插件，這邊不做贅述。\n如此一來，就完成網站的部署囉！\n\n\nDebug經驗分享：Netlify 部署Hexo Github 初始化（initializing） 失敗\n問題發現：\n建制初期，進行Hexo部落格更新時，推到Github上，理論上Netlify會自動幫我編譯與部署，但當netlify在進行初始化(initializing)動作，會跳出Failed的警告字樣，如下圖：\n\n\n\n\n\n分析觀察：\n觀察第八與第九行，可以發現，問題是出在「.deploy_git」這個檔案。發現這個檔案應該是Netlify在部署時會自動產生出的文件，git submodule 無法追蹤或更新到這份模組，導致錯誤。\n\n\n解決方法：\n參考以下連結，先將「.deploy_git」這個檔案給刪掉\n\n\n\n\n\n刪除指令：\ngit rm --cache &#x27;.deploy_git&#x27;    # system response: rm &#x27;.deploy_git&#x27;\n\n下圖為檢查與刪除的過程圖：\n\n\n\n\n並且，記得將部署檔案”.deploy_git”加入到”.gitignore”檔案裡面（若無此檔案，要自己創建），以免再次把”.deploy_git”更新上去。\n可以使用指令ls -la 看看有沒有這個檔案，若沒有，可以用指令touch .gitignore 來創造，再使用文字編輯器將檔案.gitignore 加上去即可\n\n\n編輯結束後，再將hexo的repo推上去github，讓netlify自動部署更新，就可以成功囉！\n\n\n小結\n將部署工具換成netlify之後，有種如釋負重的感覺，之前繁瑣的部署流程，可以直接推上github後就結束了，他將會幫我自動部署到網路上，輕鬆方便許多！\n遇到Bug時，一時間也覺得不知所措，但真的仔細深入了解其原因後，才發現原來解法這麼單純，但這也是玩資訊工程時的醍醐味吧！\n\n","categories":["Software"],"tags":["hexo"]}]